<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Lambda表达式]]></title>
    <url>%2F2018%2F08%2F14%2FLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简言由于之前一直使用的都是Java 7,对Java 8的一些新特性不甚了解。最近Aban学习了一下Java 8的一些新特性，在这里简单总结、分享一下关于Lambda表达式的一些东西。如有错误，还望指正。 行为参数化的思想在使用Lambda表达式之前，我们应该先理解一个重要概念—-行为参数化。行为参数化，简单来说，就是你准备好一个代码块，却不去执行它，这个代码块以后可以被程序其他部分调用。更通俗的说，就是把方法(你的代码)作为参数传递给另一个方法。比如，将代码块传递给另一个方法，稍后去执行它。这个方法的行为就基于那块代码被参数化了。例如，你要处理一个集合，你一可能会写一个方法： 对列表中的每个元素做“某件不可描述的事情” 在列表处理完后做“另一件不可描述的事情” 遇到错误时可以做“另外一件不可描述的事情”初试牛刀我们接下来看一个例子，然后展示一些让代码灵活的最佳做法。(例子较长，请耐心观看~~)有一个农场仓库，里面有很多苹果，我们用一个list集合来表示。 农民伯伯想要找出所有的绿苹果，听起来很简单：123456789public static List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; apples) &#123; List&lt;Apple&gt; greenApples = new ArrayList&lt;Apple&gt;(); for(Apple apple: apples) &#123; if("green".equals(apple.getColor())) &#123; greenApples.add(apple); &#125; &#125; return greenApples;&#125; 我们检出所有的绿苹果之后，农民伯伯改变注意了，想要找出各种颜色苹果：绿色，红色，黄色…… 再展身手，将颜色作为参数针对农民伯伯的需求，我们可以把颜色作为参数，这样会更加灵活一点：123456789public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; apples,String color) &#123; List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;(); for(Apple apple: apples) &#123; if(apple.getColor().equals(color)) &#123; result.add(apple); &#125; &#125; return result;&#125; 我们再复杂一点，农民伯伯又说，要是能区分轻的苹果和重的苹果就好了，大于100克的算是重的苹果。作为有职业操守的程序员，我们早可以想到农民伯伯可能要改变重量，于是又有了下面的方法：123456789public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; apples,int weight) &#123; List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;(); for(Apple apple: apples) &#123; if(apple.getWeight() &gt; weight) &#123; result.add(apple); &#125; &#125; return result;&#125; 虽然有了解决方案，但这有点令人失望，因为中间有很多重复的代码。 第三次尝试我们可以把筛选颜色和重量弄到一个方法里面，定义一个标识来判断是筛选颜色还是重量：12345678910public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; apples,String color,int weight,boolean flag) &#123; List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;(); for(Apple apple: apples) &#123; if((flag &amp;&amp; apple.getColor().equals(color)) || (!flag &amp;&amp; apple.getWeight() &gt; weight)) &#123; result.add(apple); &#125; &#125; return result;&#125; 你可以这么用：12List&lt;Apple&gt; greenApples = filterApples(apples,"green",0,true);List&lt;Apple&gt; heavyApples = filterApples(apples,"",100,false); 但说句实话，这个方案实在糟糕透了，如果需要组合属性做更复杂的查询，或者有更加复杂的需求，可能需要更加冗长复杂的代码(你身为程序员的职业操守呢？？？) 运用行为参数化从上面可以看到，我们需要一种更好的方法来应对变化的需求，需要更高层次的抽象。我们可以根据Apple的属性，来返回一个boolean值，我们称之为谓词(即一个返回boolean值的函数)首先，我们定义一个接口来对选择标准建模：123public interface ApplePredicate &#123; boolean test(Apple apple);&#125; 然后，我们就可以用ApplePredicate的多个实现来代表不同的选择标准：1234567public class AppleColorPredicate implements ApplePredicate&#123; //选出绿苹果 @Override public boolean test(Apple apple) &#123; return "green".equals(apple.getColor()); &#125;&#125; 1234567public class AppleWeightPredicate implements ApplePredicate&#123; //选出重的苹果 @Override public boolean test(Apple apple) &#123; return apple.getWeight() &gt; 100; &#125;&#125; 最后，我们的filter方法看起来是这样的：123456789public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; apples,ApplePredicate p)&#123; List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;(); for (Apple apple : apples) &#123; if(p.test(apple)) &#123; result.add(apple); &#125;&#125; return result;&#125; 这里，filterApples方法需要接受ApplePredicate对象，对Apple做条件测试。filterApples方法的行为取决于通过ApplePredicate对象传递的代码，换句话说，我们把filterApples方法的行为参数化了！(身为程序员的你终于有了有一丝丝尊严！！！)由此，我们对行为参数化有了更精确的解释：让方法接受多种行为作为参数，并在内部使用，来完成不同的行为。 进阶 匿名类上面的例子虽然最后算是找到一个还算好一点的方案,但还是有点费劲。我们可以使用匿名内部类，它允许你随用随建。 1234567List&lt;Apple&gt; redApples = filterApples(apples,new ApplePredicate() &#123; //筛选红苹果 @Override public boolean test(Apple apple) &#123; return "red".equals(apple.getColor()); &#125;&#125;); 使用Lambda表达式但匿名类还是不够好，它往往很笨重，占用很多空间；而且很多程序员觉得它用起来很费解。(唉，处女座就是麻烦…)在Java 8中，可以用Lambda表达式写成下面的样子： 1List&lt;Apple&gt; result = filterApples(apples,(Apple apple) -&gt; "red".equals(apple.getColor())); Lambda表达式Lambda表达式的基本语法是：1(parameters) -&gt; expression 或(请注意语句的花括号)1(parameters) -&gt; &#123; statements; &#125; 比如我们利用Lambda表达式比较两个苹果的重量：这个Lambda表达式有三个部分： 参数列表 —— 这里采用了Comparator中compare方法的参数,两个Apple 箭头 —— 箭头 -&gt; 把参数列表和Lambda主体分隔开 Lambda主体 —— 比较两个Apple的重量，表达式就是Lambda的返回值了什么时候可以使用LambdaLambda表达式是可以在函数式接口上使用的。函数式接口就是只定义一个抽象方法的接口。比如：1234567891011public interface Predicate&lt;T&gt;&#123; boolean test (T t);&#125;public interface Comparator&lt;T&gt;()&#123; int compare(T o1,T o2);&#125;public interface Runnable&#123; void run();&#125; 其实，Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例(确切来说，是函数式接口的一个具体实现的实例)。 Lambda表达式的具体使用 如果我们想要从一个文件中读取一行所需的内容，可以定义这样的方法：123456public static String processFile() throws IOException &#123; try (BufferedReader br = new BufferedReader(new FileReader("data.txt")))&#123; return br.readLine(); &#125;&#125; 那如果要读取两行呢，这时候我们就应该记起来行为参数化。 使用函数式接口来传递行为前面已经说过，Lambda仅可用于上下文是函数式接口的情况。我们需要创建一个匹配BufferedReader -&gt; String，还可以抛出异常的接口。123public interface BufferedReaderProcessor &#123; String process(BufferedReader br) throws IOException;&#125; 现在，我们可以把这个接口作为processFile方法的参数：123456public static String processFile(BufferedReaderProcessor p) throws Exception&#123; try (BufferedReader br = new BufferedReader(new FileReader("data.txt")))&#123; return p.process(br); &#125;&#125; 传递Lambda现在我们就可以通过传递不同的Lambda重用processFile方法，以不同方式处理文件。 处理一行: 1String oneLine = processFile((BufferedReader br) -&gt; br.readLine()); 处理两行: 1String twoLine = processFile((BufferedReader br) -&gt; br.readLine() + br.readLine()); 几种函数式接口Java 8中常用的函数式接口有三个:Predicate,Consumer,Function。这里我们简单介绍使用一下，具体使用有兴趣可以自己实践下。 Predicatejava.util.function.Predicate接口定义了一个名叫test的抽象方法，它接受泛型T对象，并返回一个boolean。在需要表示一个涉及类型T的布尔表达式时，可以使用这个接口。比如，你可以定义一个接受String对象的Lambda表达式。1234567891011121314151617@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; boolean test(T t);&#125;public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p) &#123; List&lt;T&gt; results = new ArrayList&lt;&gt;(); for(T s: list)&#123; if(p.test(s))&#123; results.add(s); &#125; &#125; return results; &#125; Predicate&lt;String&gt; predicate = (String s) -&gt; !s.isEmpty(); List&lt;String&gt; nonEmpty = filter(listOfStrings, predicate); Consumerjava.util.function.Consumer接口定义了一个名叫accept的抽象方法,它接受泛型T，没有返回值(void)。如果需要访问类型T的对象，并对其执行某些操作，可以使用这个接口。比如定义一个forEach方法，接受一个Integer类型的列表，并对每个元素执行打印操作。1234567891011121314@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t);&#125;public static &lt;T&gt; void forEach(List&lt;T&gt; list,Consumer&lt;T&gt; c) &#123; for(T i: list) &#123; c.accept(i); &#125;&#125;forEach( Arrays.asList(1,2,3,4,5),(Integer i) -&gt; System.out.println(i)); Functionjava.util.function.Function&lt;T, R&gt;接口定义了一个叫作apply的方法，它接受一个泛型T的对象，并返回一个泛型R的对象。如果需要定义一个Lambda，将输入的信息映射到输出，可以使用这个接口(比如提取苹果的重量，或把字符串映射为它的长度)。比如，定义一个map方法，将一个String列表映射到包含每个String长度的Integer列表。123456789101112131415161718@FunctionalInterface public interface Function&lt;T, R&gt;&#123; R apply(T t); &#125; public static &lt;T, R&gt; List&lt;R&gt; map(List&lt;T&gt; list, Function&lt;T, R&gt; f) &#123; List&lt;R&gt; result = new ArrayList&lt;&gt;(); for(T s: list)&#123; result.add(f.apply(s)); &#125; return result; &#125; // [6,3,6]List&lt;Integer&gt; list = map( Arrays.asList("lambda","int","action"), (String s) -&gt; s.length() ); Supplierjava.util.function.Supplier接口定义了一个get的抽象方法，它没有参数，返回一个泛型T的对象，这类似于一个工厂方法。比如返回一个Apple对象。123456789public interface Supplier&lt;T&gt; &#123; T get();&#125;public static &lt;T&gt; T getObject(Supplier&lt;T&gt; s) &#123; return s.get();&#125;Apple apple = getObject(() -&gt; new Apple()); 方法引用我们上面写到的Lambda表达式是很方便的，但确实它们可以再简洁一点，比如根据苹果重量对集合进行排序，Lambda表达式是这样的：1apples.sort((Apple a1,Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight())); 使用 方法引用 和 java.util.Comparator.comparing 可以写成这样子：1apples.sort(comparing(Apple::getWeight)); 基本格式方法引用显式地指明调用的方法的名称，使代码的可读性更好。当你想要使用方法引用时，目标引用放在分隔符 : : 前，方法名称放在后面：下面给出了一些Java 8中方法引用的例子： 如何构建方法引用主要有三类。 指向静态方法的方法引用(例如Integer 的 parseInt 方法) 1Integer :: parseInt 指向任意类型实例方法的方法引用(例如String 的 length 方法) 1String :: length //实例为方法参数 指向现有对象的实例方法的方法引用(假设你有一个局部变量transaction，为Transaction类型，它支持实例方法getValue，就可以写成下面这样) 1Transaction :: getValue //实例为外部对象 第2钟和第3钟乍一看有点晕，其实第二种方法引用的思想就是你在引用一个对象的方法，这个对象本身是lambda的一个参数；第三种方法引用是你再调用一个已经存在的外部对象的方法。 构造函数引用上面我展示了如何创建方法引用，其实我们也可以对类的构造函数做类似的事情。我们可以利用 ClassName :: new 的形式构建一个构造函数的引用。假设一个构造函数没有参数，它试合Supplier的签名() -&gt; Apple:12Supplier&lt;Apple&gt; supplier = Apple :: new;Apple apple = supplier.get(); 在使用方法引用之前它是这样的：12Supplier&lt;Apple&gt; supplier = () -&gt; new Apple();Apple apple = supplier.get(); 如何你的构造函数是有参数的，比如签名是Apple(Integer weight),那么它就适合Function接口的签名：12Function&lt;Integer,Apple&gt; func = Apple :: new;Apple apple = func.apply(100); 这就等价于：12Function&lt;Integer,Apple&gt; func = (weight) -&gt; new Apple(weight);Apple apple = func.apply(100); Lambda和方法引用实战接了下来我们继续研究前面的一个例子——按照苹果重量给Apple列表排序，我会展示从原始粗暴的状态到更加简明状态的过程，而且会用到前面提到的概念和功能：行为参数化、匿名类、Lambda表达式和方法引用。 行为参数化——传递代码Java 8的API已经为我们提供了一个List可用的sort方法，我们可以直接使用。我们可以看下sort方法的签名：1void sort(Comparator&lt;? super E&gt; c) 它需要一个Comparator对象来比较两个Apple，所以第一个方案可以是这样的：12345678910public class AppleComparator implements Comparator&lt;Apple&gt;&#123; @Override public int compare(Apple a1, Apple a2) &#123; return a1.getWeight().compareTo(a2.getWeight()); &#125;&#125;apples.sort(new AppleComparator()); 使用匿名类我们可以使用匿名类来改进，而不是实现一个Comparator却只实例化一次：12345apples.sort(new Comparator&lt;Apple&gt;() &#123; public int compare(Apple a1, Apple a2) &#123; return a1.getWeight().compareTo(a2.getWeight()); &#125;&#125;); 使用Lambda表达式使用匿名类的方案还挺啰嗦的，既然我们了解了Lambda表达式，它可以用更轻量级的语法来传递代码。我们需要记住这一点：在需要函数式接口的地方可以使用Lambda表达式，抽象方法的签名描述了Lambda表达式的签名。Comparator接口抽象方法的签名是符合这种形式的——(T,T) -&gt; int。所以我们改进后的方案是这样的：123apples.sort((Apple a1,Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight())); 其实，Java的编译器是可以根据Lambda出现的上下文来推断Lambda表达式参数的类型的：1apples.sort((a1,a2) -&gt; a1.getWeight().compareTo(a2.getWeight())); Comparator接口其实有一个comparing的静态方法，可以接受一个Function，并返回一个Comparator对象。像下面这样：1Comparator&lt;Apple&gt; c = Comparator.comparing((Apple a) -&gt; a.getWeight()); 这时候我们的代码就可以更简洁一点了：123import static java.util.Comparator.comparing;apples.sort(comparing(a -&gt; a.getWeight())); 使用方法引用最后，我们可以使用方法引用来完成最终解决方案：1apples.sort(comparing(Apple::getWeight)); 总结在了解了Lambda表达式的和方法引用的用法之后，你就可以自己去尝试用Lambda表达式去简化一些代码了(你可以自己去练习一下)。不过用于传递Lambda表达式的Comparator、Function、Predicate等函数式接口提供了允许你进行复合的方法。这意味着你可以把多个简单的Lambda复合成复杂的表达式。有兴趣的童鞋可以自己去了解下，这里不再详细讲解。]]></content>
      <categories>
        <category>Java 8</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>分类1</category>
      </categories>
  </entry>
</search>
